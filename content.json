{"pages":[{"title":"关于","text":"我，是一名初中生，这个博客是我闲来无事搭建的，里面一般会记录一些笔记、吐槽（我会尽量控制篇数）、题解等。 但是有一点需要声明，我所编写的文章可能并没有什么含金量，描述也可能并不是那么准确和生动。 我有时候会写一些没啥用的项目（是真的没用），一般情况他们都可以在 项目 一栏中找到，但说实话，他们都没啥技术含量。我一般会使用 C++ 或 TurboWarp 来编写这些东西，虽然我一懂一点其他语言的皮毛。 最后如果你有事可以用我留的联系我，但因为我的身份原因和一些客观限制，导致我可能并不能很快回复或处理，甚至你可能得不到回复，请见谅（这一点适用于所有事，包括我自己的事）。","link":"/about/index.html"},{"title":"友链","text":"以下友链已失联，如果您是其站长或知道其目前网址，请联系我进行更换 如果您想交换友链，请联系我，我会尽快处理","link":"/links/index.html"},{"title":"项目","text":"开发中（已有稳定正式版） 维护中（不会有大改动） 测试中（可能有许多 bug） 已弃坑（不再进行维护）","link":"/project/index.html"}],"posts":[{"title":"chrome 浏览器插件安装教程","text":"声明 本篇文章主要用于无法访问谷歌 谷歌应用商店 的人群，如您能访问谷歌应用商店，建议直接去谷歌商店下载安装。 下载插件 由于某些原因，国内是无法直接访问谷歌应用商店的，所以肯定需要其他存储站。这里推荐使用 极简插件，它的插件都是谷歌商店上的，它有时会收录 Edge 版本，有时候还会保留一些谷歌商店上已经下架的插件（他会有所提醒）。（不是广告） 在极简插件上下载插件是一定要注意看它的最新版是否支持您的谷歌版本： 1. 首先如果该插件对 chrome 浏览器版本的要求有可能导致某些用户安装失败，它会在文中提醒，有时也会在文中贴出兼容旧版 chrome 浏览器拓展版本。 2. 如果你仍不放心，可以点击 `历史版本`（一般只有热门的拓展有），下载最新支持你的 chrome 浏览器的版本。 如果您不知道您 chrome 浏览器的版本，可以在网址栏中输入 chrome://settings/help 查看您 chrome 浏览器的版本。 Google 官方于 5 月 30 日发布公告,宣布将从 6 月 3 日开始,逐步淘汰 Manifest V2 扩展程序标准,并推荐用户使用新的 Manifest V3 标准。 而 Manifest V3 标准需要的最低内核版本要求是 Chrome 124 及以上。 也就是说如果你是 chrome 浏览器，目前版本低于 Chrome 124，就有可能无法安装最新版本的插件。 安装插件 解压下载的压缩包。 在网址栏输入 chrome://extensions/ 打开插件管理界面，点击右上角打开 开发者模式（如果你已经打开了就不用管了）。 将解压出的文件中的 .crx文件拖到窗口中（请确保页面位拓展程序管理页面），加载它。然后一直等到显示类似如图弹窗。 点击 添加拓展程序以加载这个拓展程序。 如果有显示类似 程序包无效 的提示，说明你的 chrome 浏览器版本可能过低，请更新你的 chrome 浏览器或者前去你下载插件的地方下载兼容旧版本的插件。 【可选】 配置（设置）拓展 一般的插件都会给插件些一个设置界面，但如果你想配置这个插件的权限或者它没有弹出设置界面，你试试以下步骤。 在网址栏输入 chrome://extensions/ 打开插件管理界面。 找到你要配置的插件，点击它左下角的 详情 按钮，在这里你就可以配置它的权限了。而插件自己的设置页面一般在 扩展程序选项 （如图）里。 如果你在上面没有找到插件的设置界面，你可以点击浏览器菜单栏的左上角的插件按钮 ，找到你要找的插件。 找到你要设置的插件：你可以点击它来打开它的页面（里面可能有一些设置）；点击中间的大头针可以将其固定在菜单栏上，以后只用点击菜单栏上的图表就可以打开它的页面；点击右边的三个点可以设置更多，具体的请自己研究，这里因为篇幅原因不赘述了。 这篇博客就写到这了，快去位你的 chrome 浏览器增添新功能吧，如果有不懂或者要补充的可以提出。","link":"/2025/07/31/chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"使用 Hexo + Github 搭建博客","text":"前言 声明 这篇文章更倾向于是一篇博客搭建经历，可能并不能作为一个很好的教程。 我很早之前就有过一个想要搭建自己博客的想法，但因为电脑是 32 位一直没能实现。 直到这天，我突然想起我的树莓派，它是 64 位的，也就是说它可以完成这些操作，于是我便开始了实践…… 准备工作 如果您已经完成以下准备工作，可以直接从 配置 Hexo 博客 开始。 去 git 官网 下载安装 git。 去 Node.js 官网 下载安装 Node.js，其中最后一个空建议选 npm，方便后续操作。 注册 github 账号： 打开 github 注册页。如果打不开或者加载很慢的话，可以搜索 steam++；实在不行就自行百度其他方法吧。（注册完成之后可以访问 https://kkgithub.com，再这在登录一遍，他的效果和官网 github 是一样的（除了不能注册），访问速度有可能会更快） 如图填写相应内容进行注册（我这是用插件翻译后的效果，github是纯英文的，原页面不长这样，但要求和须填写的内容是一样的）。其中邮箱的话 QQ 邮箱就行（对于没有邮箱的人群），至于如何注册邮箱，请自行百度。最好（或是说一定）不要用临时邮箱！ 之后他会验证你的账户（是这样吧？），然后会给你的邮箱发一封邮件，同时显示如图页面，你只要将邮件里的验证码填入其中就行（应该很好找，不会英文都行，我没记错的话应该是纯数字。当然如果有找不到或者觉得有必要单独说明在哪的，可以提出。）。之后我没记错的话应该是就注册好了。 打开命令行（Windows就按快捷键 win + R 调出运行框，输入 CMD），输入以下命令，安装Hexo。 1npm install -g hexo-cli 【可选】 全文涉及网站大多均为国外网站，作者提供的网址已经尽力多为官方中文页面了，但仍有少量英语页面，不善英语者可安装翻译器浏览器插件。 Google 浏览器推荐使用 沉浸式翻译:双语对照网页翻译&amp;PDF文档翻译，不会安装可以去看 安装教程。有条件的可以直接去 谷歌应用商店 安装。（不是广告） 其他浏览器就不说了，在插件库（类似）里应该都能找到和安装相关插件。 配置 Hexo 博客 完成准备工作之后，就可以初始化博客了。 在任意地方新建一个文件夹（也可以不新建，但请确保你所创建博客的文件夹内是空的）。 打开命令行（别关，后面都会用到），输入下面这行代码，转到你要创建博客的地址并初始化博客。 12cd &lt;你文件夹相对或绝对地址&gt;hexo init (这里也可以加上文件夹的绝对路径） 如果你不清楚什么是相对地址或者不会获取，建议写绝对地址。绝对地址一般打开这个文件夹时地址栏显示的就是，双击选中，然后再复制就行；或者右键该文件夹，查看属性（类似），绝对路径应该会在里面。 另外，这篇文章和相关项目所有的命令如无特殊声明，都是在这个客的根目录下完成的，如果一不小心使目录便成了其他目录，请输入以下代码返回博客的根目录。 1cd &lt;你文件夹相对或绝对地址&gt; 【可选】 接下来，你可以打开 &lt;你的博客根目录&gt;/_config.yml 这个文件，自己配置博客。具体参数因为篇幅限制不赘述，可以去 官方文档 看看。 【可选】 如果你希望有界面上的大变化可以安装主题，具体安装方法一般会在该主题的文档（README）中。Hexo 目前的默认主题是 landscape，在 官方的主题库 中收录了许多好看的主题，这个博客所用的主题是 hexo-theme-Anatolo。请注意，安装完主题后一定要将 &lt;你博客的根目录&gt;/_config.yml 中的 theme的值改为你要用的主题的名称，注意大小写。 【可选】 如果你希望博客能有一些新功能你可以安装插件，具体安装、配置方法一般会在该拓展的文档（README）中，记得一定要在将 &lt;你博客的根目录&gt;/_config.yml 中的 Plugins的值加上这个插件的名称，注意大小写。 【可选】 自定义设置。由于有些复杂，对于新手来说难度太大（我绝对不会告诉你是因为我自己也没怎么懂），暂时不写。 写作 编写一般分为多种，这里只介绍默认的 3 种： 页面。顾名思义，就是编写一个页面（如友链页面、关于界面等），而非文章，其一般可以在命令框中输入以下命令创建，其相关文件一般会生成在 &lt;你博客的根目录&gt;/source/&lt;你生成文件时设定的标题（目录名）&gt; 中，你可以打开里面的 .md 进行编写。 1hexo n page &quot;&lt;你给这篇文章取的标题（目录名）&gt;&quot;","link":"/2025/07/29/%E4%BD%BF%E7%94%A8-hexo-github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"title":"游戏构想","text":"","link":"/2025/07/31/%E6%B8%B8%E6%88%8F%E6%9E%84%E6%83%B3/"},{"title":"笔记","text":"hhh ::: warning 这是一个警告信息 ::: !!! title 重要提醒： 此笔记记录C++相关知识点，由Czihan学习过程中编写，不保证准确性和完整性，仅供参考，阅读时请注意甄别。 另外，该笔记的分类和样式有部分很奇怪，我正在尽力处理此事情，请见谅。 有任何问题都可以前往[此处](https://www.luogu.com.cn/user/1489866)反馈 线性筛 &amp; 埃氏筛 埃氏筛（伪代码）： 12遍历： 若为没被标记，则从其本身开始标记其的整数倍； 线性筛（伪代码）: 12345遍历： 1. 若为没被标记，放入质数表； 2. 枚举质数表中的数： 2.1 标记(枚举到的数*枚举到的质数) 2.2 若枚举到的数为枚举到的质数的整数倍，则退出循环 分治 概念： 将一大任务分成两个近似的较小任务解决，最后再合并（类似递归）。若平均分后仍无法解决，则继续分。 典型例子： 快速排序（伪代码）： 1231. 先随机找一个参照值，去应为小的那边找比其大的（反之则找比其小的），并标记2. 将标记过的比其大的和比其小的交换3. 再将数组分成两半，两半分别重复所有动作，直至仅剩一个元素 归并排序（伪代码）： 1231. 将数组分成两半，直至操作的那个数组仅剩一个元素2. 跳回上一步，与上一步分出的另一个数组有序地合并（若另一个数组已执行了相同步骤，即其有序。若无序，则让另一个数组执行1. ）3. 重复执行2. ，直至有序 链表 ： 二分 找最前面的该数代码： 123456while (l &lt;= r) { int mid = (r - l) / 2 + l; if (a_y[mid] &gt;= a_x[i]) r = mid - 1; else l = mid + 1;}注意：l为这个数 找最后面的该数代码： 123456while (l &lt;= r) { int mid = (r - l) / 2 + l; if (a_y[mid] &gt; a_x[i]) r = mid - 1; else l = mid + 1;}注意：l为其下表+1的数 **重点注意：**若没找到，r和l分别为其左右最接近的数 sizeof() sizeof(对象)可以求一个对象所占的字节数 memset() memset( 对象 , 要成初始化的数 , 初始化的字节数 )可以初始化一个对象的几个字节为同一个数 指针 1234int a;int *p=&amp;a;//指针变量p存储变量a的地址*p//解引用：在这是表示指针变量p所存的地址的值int b=&amp;a;//引用：在这是将变量b本身的地址设为变量a本身的地址（他们用同一个地址） 结构体 1234567891011121314struct a{ int x; int y; friend bool operator&lt;(Node a,Node b){//该结构体的朋友函数//“operator&lt;”为重定义运算符“&lt;” return a.dis&gt;b.dis; } //该做法可用于在优先队列中使用结构体的情况。}x;//可直接在这此这样定义a x;//也可这样定义&amp;x//为该结构体第一项的地址（数组也同样）&amp;x+n//为该结构体第1+n项的地址（数组也同样）x//该结构体的第一项（数组也同样）x+n//为该结构体第1+n项的地址（数组也同样） const const是常量修饰符，被它修饰的变量在初始化后无法被修改 DFS（深度优先搜索）模板 12345678910void dfs( int pos ){ 判断终点 处理数据 返回 枚举pos位置的所有可能情况: 判断 给pos位置赋值 dfs()搜索下一个位置 返回} BFS（广度优先搜索）模板 123456789while(队列判空){ 取队头 删队头 标记 枚举位置的所有可能情况{ 判断 入队 }} strcmp() strcmp(S1,S2)可以判断两个字符串（在这是S1和S2）是否一致 map **概念：**map以&lt;key,value&gt;键值对的形式存储，且map的内部自建一个红黑树，使得其可以自动排序。 特点： 第一个可以称为关键字(key)，每个关键字只能在map中出现一次； 第二个可以称为该关键字的值(value)； key既不能重复也不能被修改 **用处：**map在做数据映射的时候能够非常简便的完成代码构建，并且保持查询高效。 123456789101112131415161718192021222324252627#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;int main(){ map&lt;string,int&gt; a; //第一个表示key数据类型，第二个表示value数据类型 a[&quot;one&quot;] = 1; a[&quot;tow&quot;] = 2; a[&quot;one&quot;] = 3; //赋值时，key值作为下标，后面的数据作为对应key的value元素，在map中新添加一对数据 //赋值时，如果key值已经存在，表示将此key值对应的value元素修改为新的数据 cout &lt;&lt; a[&quot;one&quot;] &lt;&lt; endl; //key值可以作为下标，直接输出对应的元素 cout &lt;&lt; a[&quot;three&quot;] &lt;&lt; endl; //注意：下标访问不会做下标检查，如上语句不会报错，但打印结果为空，因为下标访问会插入不存在的key，对应的value为默认值 a.insert({&quot;three&quot;,3}); //将指定键值对插入到map中，插入元素会自动插入到合适的位置，使整个map有序，默认是按照key从小到大排序 a.erase(&quot;one&quot;); //删除指定key值的键值对 cout &lt;&lt; a.count(&quot;three&quot;) &lt;&lt; endl; //查询指定key值是否出现 cout &lt;&lt; a.empty() &lt;&lt; endl; //判断是否为空，非空为0，空为1 cout &lt;&lt; a.size() &lt;&lt; endl; //获取map长度 map&lt;string,int&gt;::iterator it = a.begin(); //创建一个map类型迭代器 for(;it!=a.end();it++){ cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } //遍历并输出，因为是类结构体指针，每个键值对通过first访问key，second访问value return 0;} set **概念：**set里面每个元素只存有一个key，它支持高效的关键字查询操作。 特点： 储存同一类型的数据元素（这点和vector、queue等其他容器相同） 每个元素的值都唯一（没有重复的元素） 根据元素的值自动排列大小（有序性） 无法直接修改元素 高效的插入删除操作 **用处：**set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的 1234567891011121314151617181920#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;int main(){ set&lt;int&gt; a; //定义一个集合 int arr[5]= {0,5,13,19}; set&lt;int&gt; b(arr,arr+5); //定义并初始化集合元素从数组arr中获取 set&lt;int&gt;::iterator it = b.begin(); //创建一个set类型迭代器 for(;it!=b.end();it++){ cout &lt;&lt; *it &lt;&lt; endl; } //遍历并输出 cout &lt;&lt; b.empty() &lt;&lt; endl; //判断是否为空，非空为0，空为1 cout &lt;&lt; b.size() &lt;&lt; endl; //获取集合长度 cout &lt;&lt; b.count(13) &lt;&lt; endl; //统计集合中指定元素出现的次数 b.insert(8); //将指定元素插入到集合中，插入元素会自动插入到合适的位置，使整个集合有序 b.erase(13);//删除指定的元素 return 0;} 栈 12345678910#include&lt;stack&gt;//栈:1、先进后出//2、只能从一端进出，另一端封闭push();//往栈里添加一个元素 (进栈、入栈、压栈) pop();//从栈顶删除一个元素 (出栈、弹栈)top();//访问栈顶元素empty();//判断栈是否为空，如果为空 1size();//获取栈中元素的个数 队列（所有） 12345678910111213141516171819202122232425262728#include&lt;queue&gt;//头文件#include&lt;deque&gt;//双端队列头文件using namespace std;//队列:1、先进先出//2、从一端进，另一端出//进数据的一端：队尾//出数据的一端：队首//双端队列除外queue&lt;int&gt; q;//正常队列priority_queue&lt;int&gt; q;//优先队列，默认优先级从大到小，用法见栈priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//优先级从小到大priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;//优先级从大到小deque&lt;int&gt; que;//双端队列push();//从队尾添加一个元素 (入队)push_front();//从队首添加一个元素 (入队)。（对于双端队列）push_back();//从队尾添加一个元素 (入队)。（对于双端队列）que[1];//下标访问（并不会检查是否越界）。（对于双端队列）pop();//从队首删除一个元素 （）出队）。pop_front();//删除队首元素（出队）。（对于双端队列）pop_back();//删除队尾元素（出队）。（对于双端队列）front();//访问队首元素。back();//访问队尾元素。empty();//判断栈是否为空，如果为空 1。size();//获取栈中元素的个数。que.clear();//清空所有元素。 快读快写 12345678910111213141516171819202122232425262728inline int read(){ //快读，用getchar()来代替输入 int x=0; bool w=1; char ch=getchar(); while(ch&lt;48||ch&gt;57){ if(ch==45) w=0; ch=getchar(); }while(ch&gt;47&amp;&amp;ch&lt;58){ x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch=getchar(); } return w?x:(-x);}inline void write(int x){ //快写，用putchar() if(x&lt;0){ putchar(45); x=-x; } if(x&gt;9) write(x/10); putchar(x%10+48);}int main(){ int k = read(); //输入 write(k); //输出 return 0;} freopen() **作用：**重定向标准输入或输出 1freopen(&quot;文件名&quot;,&quot;读或写（r或w）&quot;,重定向标准输入还是输出（stdin还是stdout）); vecotor（动态数组） 123456789101112131415161718#include&lt;vector&gt;vector&lt;int&gt; v1;//创建一个空的动态数组vector&lt;int&gt; v2(10);//创建一个空间为10的动态数组，元素默认值为0vector&lt;int&gt; v3(5,3);//创建一个空间为5的动态数组，元素默认值为3vector&lt;int&gt; v4(v3);//创建一个动态数组，其内容拷贝v3int a[100] = {1,2,3,4,5,6,7,8,9,10};vector&lt;int&gt; v5(a, a+5);//拷贝数组a[0]~a[4]的元素到动态数组v5中v1.push_back(x);//在动态数组v1最后添加一个元素xv1.pop_back();//删除动态数组v1最后一个元素v1.front();//访问(获取)动态数组v1第一个元素v1.back();//访问(获取)动态数组v1最后一个元素v1.erase(x);//删除指定位置的元素，x是一个迭代器v1.begin();//获取动态数组第一个元素的迭代器v1.end()-1;//获取动态数组最后一个元素的迭代器v1.size();//获取动态数组中的元素个数v1.empty();//判空v1.clear();//清空动态数组 pair 12#include&lt;utility&gt;pair&lt;int,int&gt;//pair有且只有2个元素 dijkstra最短路径（图）算法 **时间复杂度：**O(n^2) **限制：**只能解决无负权、单源（单一源头）的图的问题 **特点：**dis数组中的最小值一定为最短路 tips：堆优化版本时间复杂度更小，特点、限制一样 伪代码： 12345678void dj(){ dis初始化为inf，dis[起点] 设为0 vis初始化为0 循环顶点次数： 1. 循环查找dis数组中 *未被标记的* 最小值及其位置 pos 2. 用vis标记pos点 3. 枚举pos为起点的所有边，更新总起点到这些边的终点的dis值} **代码**： 123456789101112void dj(){ for(int i=0;i&lt;=n;++i) dis[i]=1e8; dis[a]=0; for(int i=1;i&lt;=n;++i){ int pos=0; for(int j=1;j&lt;=n;++j) if(!(vis[j])) pos=(dis[pos]&lt;dis[j]?pos:j); vis[pos]=1; for(pair&lt;int,int&gt; x : gh[pos]) dis[x.first]=min(dis[x.first],dis[pos]+x.second); }} dijkstra最短路径（图）算法（堆优化） **时间复杂度：**O((m+n)× log(n)) **限制 &amp; 特点：**同优化前 伪代码： 12345678910void dj(){ dis初始化为inf，dis[起点] 设为0 vis初始化为0，并起点入队 循环顶点次数： 1. 出队找最小值 2. 如果tmp.pos被标记 continue 3. 用vis标记pos点 4. 枚举pos为起点的所有边，更新总起点到这些边的终点的dis值 特别注意判断终点是否有被标记} **代码**： 1234567891011121314151617181920212223242526struct Node{ int pos,dis; friend bool operator&lt;(Node a,Node b){ return a.dis&gt;b.dis; }}; vector&lt; pair&lt;int,int&gt; &gt; gh[100005];int n,m,a,dis[100005];bool vis[100005];priority_queue&lt;Node&gt; q;void dj(){ for(int i=0;i&lt;=n;++i) dis[i]=1e9+5; dis[a]=0,q.push({a,0}); while(q.size()){ Node tmp=q.top(); q.pop(); if(vis[tmp.pos]) continue; vis[tmp.pos]=1; for(pair&lt;int,int&gt; x : gh[tmp.pos]){ dis[x.first]=min(dis[x.first],dis[tmp.pos]+x.second); q.push({x.first,dis[x.first]}); } }} top（拓扑排序） 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; mp[100005], tp;bool top( int n, int m, int* du ){ stack&lt;int&gt; st; int cnt = 0; for( int i=1; i&lt;=n; ++i ) if(du[i]==0) st.push(i); while( st.size() ){ int tmp = st.top(); tp.push_back(tmp); st.pop(); for( int node : mp[tmp] ){ if(--du[node]==0) st.push(node); } cnt++; } return cnt==n;}int main(){ int n, m, du[100005]={},v1,v2; cin &gt;&gt; n &gt;&gt; m; for( int i=1; i&lt;=m; ++i ){ cin &gt;&gt; v1 &gt;&gt; v2; du[v2]++; mp[v1].push_back(v2); } if( top(n,m,du) ) for( int x:tp ) cout &lt;&lt; x &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot; has cicle&quot;; return 0;} Floyd最短路径（图）算法 **时间复杂度：**O(n^3) **限制：**可解决有负权、多源（多源头）的图的问题 **特征：**dp数组（没错，是动态规划）中的最小值一定为最短路 伪代码： 1234567for (中转点 k) { for (起点 i) { for (终点 j) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]); } }} 代码： 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int dp[105][105], n, m;int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(dp, 0x3f, sizeof(dp));//dp数组每个字节填充0x3f for (int i = 0; i &lt;= n; i++) dp[i][i] = 0;//dp数组对角线（i=j）填充0 for (int i = 1; i &lt;= m; i++) { int v1, v2, w; scanf(&quot;%d%d%d&quot;, &amp;v1, &amp;v2, &amp;w); //赋值并避免重边 if (dp[v1][v2] &gt; w) dp[v1][v2] = dp[v2][v1] = w; } //动规 for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]); //输出 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) printf(&quot;%d &quot;, dp[i][j]); printf(&quot;\\n&quot;); } return 0;}","link":"/2025/08/09/%E7%AC%94%E8%AE%B0/"},{"title":"链接","text":"链接 pcl2最新版 TurboWarp python 小熊猫C++ C++参考手册 VS Code Visual Studio AI编程工具： 通义灵码 Fitten Code Mars Code ACGO 简易网站工具 huang1111网盘 便民查询工具 贝贝工具箱 unsplash-免费美图（堪比bing） 16图床 风铃动漫 樱花动漫 绮梦·星火动漫 视频解析（原全民解析） 工具 工具 图片转字符画 音乐：https://zz123.com/search/?key=你想搜的音乐名 音乐、电影2合一 音乐 音乐 带权限管理的免费数据库（页面无法正常获取加载css） 二次元图片 工具哇 工具集 免费短网址 Tor浏览器 免费图床 免费游戏 免费图片生成（未亲测） 爱发电 樱花动漫 桑帛云免费图床 网站多节点Ping测试 在线请求 penguinmod 蝾螈池 刘明野的工具箱 洛谷相关工具 免费图床（需注册） 网络剪贴板（目前个人认为最好用的） 网络剪贴板（更推荐用API） 栗次元API 极简插件（谷歌浏览器的插件） 使用临时、免费号码接收短信 链接乱堆处: https://raphael.app/zh https://anyvoice.net/zh https://carbon.now.sh/ https://intensedebate.com/ https://free-for.dev/#/ https://www.toolsetlink.com/ https://notegen.top/cn/","link":"/2025/08/09/%E9%93%BE%E6%8E%A5/"}],"tags":[{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"日常记录","slug":"日常记录","link":"/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"categories":[]}