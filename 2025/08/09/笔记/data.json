{"title":"笔记","date":"2025-08-09T08:21:23.000Z","toc":true,"summary":"记录我平时学习C++时的一些知识点","source":"_posts/笔记.md","raw":"---\ntitle: 笔记\ndate: 2025-08-09 16:21:23\ntags:\n  - 编程\n  - 日常记录\n  - 笔记\ntoc: true\nsummary: 记录我平时学习C++时的一些知识点\n---\n<div class=\"title\">\n此笔记由我在学习过程中编写，不保证准确性和完整性，如有错误请指出。\n另外，该笔记的分类和样式有部分很奇怪，我正在尽力处理此事情，请见谅。\n</div>\n---\n- #### 线性筛 & 埃氏筛\n\t**埃氏筛（伪代码）：**\n\t```cpp\n遍历：\n    若为没被标记，则从其本身开始标记其的整数倍；\n\t```\n\t**线性筛（伪代码）:**\n\t```cpp\n遍历：\n    1. 若为没被标记，放入质数表；\n    2. 枚举质数表中的数：\n        2.1 标记(枚举到的数*枚举到的质数)\n        2.2 若枚举到的数为枚举到的质数的整数倍，则退出循环\n\t```\n---\n- #### 分治\n\t- **概念：** 将一大任务分成两个近似的较小任务解决，最后再合并（类似递归）。若平均分后仍无法解决，则继续分。\n\t- **典型例子：**\n\t\t1. 快速排序（伪代码）：\n\t\t```cpp\n1. 先随机找一个参照值，去应为小的那边找比其大的（反之则找比其小的），并标记\n2. 将标记过的比其大的和比其小的交换\n3. 再将数组分成两半，两半分别重复所有动作，直至仅剩一个元素\n\t\t```\n\t\t2. 归并排序（伪代码）：\n\t\t```cpp\n1. 将数组分成两半，直至操作的那个数组仅剩一个元素\n2. 跳回上一步，与上一步分出的另一个数组有序地合并（若另一个数组已执行了相同步骤，即其有序。若无序，则让另一个数组执行1. ）\n3. 重复执行2. ，直至有序\n\t\t```\n\n---\n- #### 链表\n\t**：**\n\n\n---\n- #### 二分\n\t**找最前面的该数代码：**\n\t```cpp\nwhile (l <= r) {\n\tint mid = (r - l) / 2 + l;\n\tif (a_y[mid] >= a_x[i]) r = mid - 1;\n\telse l = mid + 1;\n}\n注意：l为这个数\n\t```\n\t**找最后面的该数代码：**\n\t```cpp\nwhile (l <= r) {\n\tint mid = (r - l) / 2 + l;\n\tif (a_y[mid] > a_x[i]) r = mid - 1;\n\telse l = mid + 1;\n}\n注意：l为其下表+1的数\n\t```\n\t**重点注意：**若没找到，r和l分别为其左右最接近的数\n\n---\n- #### sizeof()\n\n\t`sizeof(对象)`可以求一个对象所占的字节数\n\n---\n- #### memset()\n\n\t`memset( 对象 , 要成初始化的数 , 初始化的字节数 )`可以初始化一个对象的几个字节为同一个数\n\n---\n- #### 指针\n\t```cpp\nint a;\nint *p=&a;//指针变量p存储变量a的地址\n*p//解引用：在这是表示指针变量p所存的地址的值\nint b=&a;//引用：在这是将变量b本身的地址设为变量a本身的地址（他们用同一个地址）\n\t```\n\n---\n- #### 结构体\n\t```cpp\nstruct a{\n\tint x;\n\tint y;\n  friend bool operator<(Node a,Node b){//该结构体的朋友函数\n//“operator<”为重定义运算符“<”\n\t\treturn a.dis>b.dis;\n\t}\n\t//该做法可用于在优先队列中使用结构体的情况。\n}x;//可直接在这此这样定义\na x;//也可这样定义\n&x//为该结构体第一项的地址（数组也同样）\n&x+n//为该结构体第1+n项的地址（数组也同样）\nx//该结构体的第一项（数组也同样）\nx+n//为该结构体第1+n项的地址（数组也同样）\n\t```\n\n---\n- #### const\n\n\t`const`是常量修饰符，被它修饰的变量在初始化后无法被修改\n\n---\n- #### DFS（深度优先搜索）模板\n```cpp\nvoid dfs( int pos ){\n\t判断终点\n\t\t处理数据\n\t\t返回\n\t枚举pos位置的所有可能情况:\n\t\t判断\n\t\t给pos位置赋值\n\t\tdfs()搜索下一个位置\n\t返回\n}\n```\n\n---\n- #### BFS（广度优先搜索）模板\n```cpp\nwhile(队列判空){\n\t取队头\n\t删队头\n\t标记\n\t枚举位置的所有可能情况{\n\t\t判断\n\t\t入队\n\t}\n}\n```\n\n\n---\n- #### strcmp()\n\t`strcmp(S1,S2)`可以判断两个字符串（在这是S1和S2）是否一致\n\n---\n- #### map\n\n\t**概念：**map以<key,value>键值对的形式存储，且map的内部自建一个红黑树，使得其可以自动排序。\n\n\t**特点：**\n\t- 第一个可以称为关键字(key)，每个关键字只能在map中出现一次；\n\t- 第二个可以称为该关键字的值(value)；\n\t- key既不能重复也不能被修改\n\n\t**用处：**map在做数据映射的时候能够非常简便的完成代码构建，并且保持查询高效。\n```cpp\n#include <map>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tmap<string,int> a; //第一个表示key数据类型，第二个表示value数据类型\n    a[\"one\"] = 1; \n    a[\"tow\"] = 2;\n    a[\"one\"] = 3;\n    //赋值时，key值作为下标，后面的数据作为对应key的value元素，在map中新添加一对数据\n    //赋值时，如果key值已经存在，表示将此key值对应的value元素修改为新的数据\n    cout << a[\"one\"] << endl;\n    //key值可以作为下标，直接输出对应的元素\n    cout << a[\"three\"] << endl;\n    //注意：下标访问不会做下标检查，如上语句不会报错，但打印结果为空，因为下标访问会插入不存在的key，对应的value为默认值\n    a.insert({\"three\",3}); //将指定键值对插入到map中，插入元素会自动插入到合适的位置，使整个map有序，默认是按照key从小到大排序\n    a.erase(\"one\"); //删除指定key值的键值对\n    cout << a.count(\"three\") << endl; //查询指定key值是否出现\n    cout << a.empty() << endl; //判断是否为空，非空为0，空为1 \n    cout << a.size() << endl; //获取map长度\n    \n    map<string,int>::iterator it = a.begin(); //创建一个map类型迭代器  \n    for(;it!=a.end();it++){\n    \tcout << it->first << \" \" << it->second << endl;\n\t} //遍历并输出，因为是类结构体指针，每个键值对通过first访问key，second访问value\n    return 0;\n}\n```\n\n---\n- #### set\n\n\t**概念：**set里面每个元素只存有一个key，它支持高效的关键字查询操作。\n\n\t**特点：**\n\t- 储存同一类型的数据元素（这点和vector、queue等其他容器相同）\n\t- 每个元素的值都唯一（没有重复的元素）\n\t- 根据元素的值自动排列大小（有序性）\n\t- 无法直接修改元素\n\t- 高效的插入删除操作\n\n\t**用处：**set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的\n```cpp\n#include <set>\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tset<int> a; //定义一个集合\n    int arr[5]= {0,5,13,19};\n    set<int> b(arr,arr+5); //定义并初始化集合元素从数组arr中获取\n    set<int>::iterator it = b.begin(); //创建一个set类型迭代器\n\tfor(;it!=b.end();it++){\n\t\tcout << *it << endl;\n\t} //遍历并输出\n    cout << b.empty() << endl; //判断是否为空，非空为0，空为1 \n    cout << b.size() << endl; //获取集合长度\n    cout << b.count(13) << endl; //统计集合中指定元素出现的次数 \n    b.insert(8); //将指定元素插入到集合中，插入元素会自动插入到合适的位置，使整个集合有序\n    b.erase(13);//删除指定的元素\n    return 0;\n}\n```\n\n---\n- #### 栈\n```cpp\n#include<stack>\n\n//栈:1、先进后出\n//2、只能从一端进出，另一端封闭\n\npush();//往栈里添加一个元素 (进栈、入栈、压栈) \npop();//从栈顶删除一个元素 (出栈、弹栈)\ntop();//访问栈顶元素\nempty();//判断栈是否为空，如果为空 1\nsize();//获取栈中元素的个数\n```\n\n---\n- #### 队列（所有）\n```cpp\n#include<queue>//头文件\n#include<deque>//双端队列头文件\nusing namespace std;\n\n//队列:1、先进先出\n//2、从一端进，另一端出\n//进数据的一端：队尾\n//出数据的一端：队首\n//双端队列除外\n\nqueue<int> q;//正常队列\npriority_queue<int> q;//优先队列，默认优先级从大到小，用法见栈\npriority_queue<int,vector<int>,greater<int> > q;//优先级从小到大\npriority_queue<int,vector<int>,less<int> > q;//优先级从大到小\ndeque<int> que;//双端队列\n\npush();//从队尾添加一个元素 (入队)\npush_front();//从队首添加一个元素 (入队)。（对于双端队列）\npush_back();//从队尾添加一个元素 (入队)。（对于双端队列）\nque[1];//下标访问（并不会检查是否越界）。（对于双端队列）\npop();//从队首删除一个元素 （）出队）。\npop_front();//删除队首元素（出队）。（对于双端队列）\npop_back();//删除队尾元素（出队）。（对于双端队列）\nfront();//访问队首元素。\nback();//访问队尾元素。\nempty();//判断栈是否为空，如果为空 1。\nsize();//获取栈中元素的个数。\nque.clear();//清空所有元素。\n```\n\n---\n- #### 快读快写\n```cpp\ninline int read(){  //快读，用getchar()来代替输入\n\tint x=0;\n\tbool w=1;\n\tchar ch=getchar();\n\twhile(ch<48||ch>57){\n\t\tif(ch==45) w=0;\n\t\tch=getchar();\n\t}while(ch>47&&ch<58){\n\t\tx=(x<<3)+(x<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn w?x:(-x);\n}\n\ninline void write(int x){  //快写，用putchar()\n\tif(x<0){\n\t\tputchar(45);\n\t\tx=-x;\n\t}\n\tif(x>9) write(x/10);\n\tputchar(x%10+48);\n}\n\nint main(){\n   int k = read(); //输入\n   write(k); //输出\n\treturn 0;\n}\n```\n\n---\n- #### freopen()\n**作用：**重定向标准输入或输出\n```cpp\nfreopen(\"文件名\",\"读或写（r或w）\",重定向标准输入还是输出（stdin还是stdout）);\n```\n\n---\n- #### vecotor（动态数组）\n```cpp\n#include<vector>\nvector<int> v1;//创建一个空的动态数组\nvector<int> v2(10);//创建一个空间为10的动态数组，元素默认值为0\nvector<int> v3(5,3);//创建一个空间为5的动态数组，元素默认值为3\nvector<int> v4(v3);//创建一个动态数组，其内容拷贝v3\nint a[100] = {1,2,3,4,5,6,7,8,9,10};\nvector<int> v5(a, a+5);//拷贝数组a[0]~a[4]的元素到动态数组v5中\n\nv1.push_back(x);//在动态数组v1最后添加一个元素x\nv1.pop_back();//删除动态数组v1最后一个元素\nv1.front();//访问(获取)动态数组v1第一个元素\nv1.back();//访问(获取)动态数组v1最后一个元素\nv1.erase(x);//删除指定位置的元素，x是一个迭代器\nv1.begin();//获取动态数组第一个元素的迭代器\nv1.end()-1;//获取动态数组最后一个元素的迭代器\nv1.size();//获取动态数组中的元素个数\nv1.empty();//判空\nv1.clear();//清空动态数组\n```\n\n---\n- #### pair\n```cpp\n#include<utility>\npair<int,int>//pair有且只有2个元素\n```\n\n---\n- #### dijkstra最短路径（图）算法\n\t**时间复杂度：**O(n^2)\n\t**限制：**只能解决无负权、单源（单一源头）的图的问题\n\t**特点：**dis数组中的最小值一定为最短路\n\t**tips**：[堆优化版本](#dijkstra最短路径图算法堆优化)时间复杂度更小，特点、限制一样\n\n\t**伪代码**：\n```cpp\nvoid dj(){\n\tdis初始化为inf，dis[起点] 设为0\n\tvis初始化为0\n\t循环顶点次数：\n\t\t1. 循环查找dis数组中 *未被标记的* 最小值及其位置 pos\n\t\t2. 用vis标记pos点\n\t\t3. 枚举pos为起点的所有边，更新总起点到这些边的终点的dis值\n}\n```\n\n\t**代码**：\n```cpp\nvoid dj(){\n\tfor(int i=0;i<=n;++i) dis[i]=1e8;\n\tdis[a]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint pos=0;\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(!(vis[j])) pos=(dis[pos]<dis[j]?pos:j);\n\t\tvis[pos]=1;\n\t\tfor(pair<int,int> x : gh[pos])\n\t\t\tdis[x.first]=min(dis[x.first],dis[pos]+x.second);\n\t}\n}\n```\n\n---\n- #### dijkstra最短路径（图）算法（堆优化）\n\t**时间复杂度：**O((m+n)× log(n))\n\t**限制 & 特点：**同[优化前](#dijkstra最短路径图算法)\n\n\t**伪代码**：\n```cpp\nvoid dj(){\n\tdis初始化为inf，dis[起点] 设为0\n\tvis初始化为0，并起点入队\n\t循环顶点次数：\n\t\t1. 出队找最小值\n\t\t2. 如果tmp.pos被标记 continue\n\t\t3. 用vis标记pos点\n\t\t4. 枚举pos为起点的所有边，更新总起点到这些边的终点的dis值\n\t\t\t特别注意判断终点是否有被标记\n}\n```\n\n\t**代码**：\n```cpp\nstruct Node{\n\tint pos,dis;\n\tfriend bool operator<(Node a,Node b){\n\t\treturn a.dis>b.dis;\n\t}\n};\n               \nvector< pair<int,int> > gh[100005];\nint n,m,a,dis[100005];\nbool vis[100005];\npriority_queue<Node> q;\n\nvoid dj(){\n\tfor(int i=0;i<=n;++i) dis[i]=1e9+5;\n\tdis[a]=0,q.push({a,0});\n\twhile(q.size()){\n\t\tNode tmp=q.top();\n\t\tq.pop();\n\t\tif(vis[tmp.pos]) continue;\n\t\tvis[tmp.pos]=1;\n\t\tfor(pair<int,int> x : gh[tmp.pos]){\n\t\t\tdis[x.first]=min(dis[x.first],dis[tmp.pos]+x.second);\n\t\t\tq.push({x.first,dis[x.first]});\n\t\t}\n\t}\n}\n```\n\n---\n- #### top（拓扑排序）\n```cpp\n#include<iostream>\n#include<stack>\n#include<vector>\nusing namespace std;\n\nvector<int> mp[100005], tp;\n\nbool top( int n, int m, int* du ){\n\tstack<int> st;\n\tint cnt = 0;\n\tfor( int i=1; i<=n; ++i ) if(du[i]==0) st.push(i);\n\twhile( st.size() ){\n\t\tint tmp = st.top();\n\t\ttp.push_back(tmp);\n\t\tst.pop();\n\t\tfor( int node : mp[tmp] ){\n\t\t\tif(--du[node]==0) st.push(node);\n\t\t}\n\t\tcnt++;\n\t}\n\treturn cnt==n;\n}\n\nint main(){\n\tint n, m, du[100005]={},v1,v2;\n\tcin >> n >> m;\n\tfor( int i=1; i<=m; ++i ){\n\t\tcin >> v1 >> v2;\n\t\tdu[v2]++;\n\t\tmp[v1].push_back(v2);\n\t}\n\tif( top(n,m,du) )\n\t\tfor( int x:tp ) cout << x << \" \";\n\telse cout << \" has cicle\";\n\treturn 0;\n}\n\n```\n\n---\n- #### Floyd最短路径（图）算法\n\t**时间复杂度：**O(n^3)\n\t**限制：**可解决有负权、多源（多源头）的图的问题\n\t**特征：**dp数组（没错，是动态规划）中的最小值一定为最短路\n\n\t伪代码：\n```cpp\nfor (中转点 k) {\n\tfor (起点 i) {\n\t\tfor (终点 j) {\n\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t}\n\t}\n}\n```\n\t代码：\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[105][105], n, m;\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tmemset(dp, 0x3f, sizeof(dp));//dp数组每个字节填充0x3f\n\tfor (int i = 0; i <= n; i++) dp[i][i] = 0;//dp数组对角线（i=j）填充0\n\tfor (int i = 1; i <= m; i++) {\n\t\tint v1, v2, w;\n\t\tscanf(\"%d%d%d\", &v1, &v2, &w);\n\t\t//赋值并避免重边\n\t\tif (dp[v1][v2] > w) dp[v1][v2] = dp[v2][v1] = w;\n\t}\n\t//动规\n\tfor (int k = 1; k <= n; k++)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\t//输出\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) printf(\"%d \", dp[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```","slug":"笔记","published":true,"updated":"2025-08-23T12:41:36.450Z","_id":"cmeoactk300086zyqbdye72nw","comments":true,"layout":"post","photos":[],"html":"<div class=\"title\">\n此笔记由我在学习过程中编写，不保证准确性和完整性，如有错误请指出。\n另外，该笔记的分类和样式有部分很奇怪，我正在尽力处理此事情，请见谅。\n</div>\n---\n- #### 线性筛 & 埃氏筛\n\t**埃氏筛（伪代码）：**\n\t<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">遍历：</span><br><span class=\"line\">    若为没被标记，则从其本身开始标记其的整数倍；</span><br></pre></td></tr></table></figure>\n\t**线性筛（伪代码）:**\n\t<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">遍历：</span><br><span class=\"line\">    <span class=\"number\">1.</span> 若为没被标记，放入质数表；</span><br><span class=\"line\">    <span class=\"number\">2.</span> 枚举质数表中的数：</span><br><span class=\"line\">        <span class=\"number\">2.1</span> 标记(枚举到的数*枚举到的质数)</span><br><span class=\"line\">        <span class=\"number\">2.2</span> 若枚举到的数为枚举到的质数的整数倍，则退出循环</span><br></pre></td></tr></table></figure>\n---\n- #### 分治\n\t- **概念：** 将一大任务分成两个近似的较小任务解决，最后再合并（类似递归）。若平均分后仍无法解决，则继续分。\n\t- **典型例子：**\n\t\t1. 快速排序（伪代码）：\n\t\t<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 先随机找一个参照值，去应为小的那边找比其大的（反之则找比其小的），并标记</span><br><span class=\"line\"><span class=\"number\">2.</span> 将标记过的比其大的和比其小的交换</span><br><span class=\"line\"><span class=\"number\">3.</span> 再将数组分成两半，两半分别重复所有动作，直至仅剩一个元素</span><br></pre></td></tr></table></figure>\n\t\t2. 归并排序（伪代码）：\n\t\t<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 将数组分成两半，直至操作的那个数组仅剩一个元素</span><br><span class=\"line\"><span class=\"number\">2.</span> 跳回上一步，与上一步分出的另一个数组有序地合并（若另一个数组已执行了相同步骤，即其有序。若无序，则让另一个数组执行<span class=\"number\">1.</span> ）</span><br><span class=\"line\"><span class=\"number\">3.</span> 重复执行<span class=\"number\">2.</span> ，直至有序</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\"></a> 链表</h4>\n<strong>：</strong></li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"二分\"><a class=\"markdownIt-Anchor\" href=\"#二分\"></a> 二分</h4>\n<strong>找最前面的该数代码：</strong>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a_y[mid] &gt;= a_x[i]) r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">注意：l为这个数</span><br></pre></td></tr></table></figure>\n<strong>找最后面的该数代码：</strong>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a_y[mid] &gt; a_x[i]) r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">注意：l为其下表<span class=\"number\">+1</span>的数</span><br></pre></td></tr></table></figure>\n**重点注意：**若没找到，r和l分别为其左右最接近的数</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"sizeof\"><a class=\"markdownIt-Anchor\" href=\"#sizeof\"></a> sizeof()</h4>\n<p><code>sizeof(对象)</code>可以求一个对象所占的字节数</p>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"memset\"><a class=\"markdownIt-Anchor\" href=\"#memset\"></a> memset()</h4>\n<p><code>memset( 对象 , 要成初始化的数 , 初始化的字节数 )</code>可以初始化一个对象的几个字节为同一个数</p>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"指针\"><a class=\"markdownIt-Anchor\" href=\"#指针\"></a> 指针</h4>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> *p=&amp;a;<span class=\"comment\">//指针变量p存储变量a的地址</span></span><br><span class=\"line\">*p<span class=\"comment\">//解引用：在这是表示指针变量p所存的地址的值</span></span><br><span class=\"line\"><span class=\"type\">int</span> b=&amp;a;<span class=\"comment\">//引用：在这是将变量b本身的地址设为变量a本身的地址（他们用同一个地址）</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"结构体\"><a class=\"markdownIt-Anchor\" href=\"#结构体\"></a> 结构体</h4>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">a</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(Node a,Node b)&#123;<span class=\"comment\">//该结构体的朋友函数</span></span><br><span class=\"line\"><span class=\"comment\">//“operator&lt;”为重定义运算符“&lt;”</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a.dis&gt;b.dis;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//该做法可用于在优先队列中使用结构体的情况。</span></span><br><span class=\"line\">&#125;x;<span class=\"comment\">//可直接在这此这样定义</span></span><br><span class=\"line\">a x;<span class=\"comment\">//也可这样定义</span></span><br><span class=\"line\">&amp;x<span class=\"comment\">//为该结构体第一项的地址（数组也同样）</span></span><br><span class=\"line\">&amp;x+n<span class=\"comment\">//为该结构体第1+n项的地址（数组也同样）</span></span><br><span class=\"line\">x<span class=\"comment\">//该结构体的第一项（数组也同样）</span></span><br><span class=\"line\">x+n<span class=\"comment\">//为该结构体第1+n项的地址（数组也同样）</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"const\"><a class=\"markdownIt-Anchor\" href=\"#const\"></a> const</h4>\n<p><code>const</code>是常量修饰符，被它修饰的变量在初始化后无法被修改</p>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"dfs深度优先搜索模板\"><a class=\"markdownIt-Anchor\" href=\"#dfs深度优先搜索模板\"></a> DFS（深度优先搜索）模板</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">( <span class=\"type\">int</span> pos )</span></span>&#123;</span><br><span class=\"line\">\t判断终点</span><br><span class=\"line\">\t\t处理数据</span><br><span class=\"line\">\t\t返回</span><br><span class=\"line\">\t枚举pos位置的所有可能情况:</span><br><span class=\"line\">\t\t判断</span><br><span class=\"line\">\t\t给pos位置赋值</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>()搜索下一个位置</span><br><span class=\"line\">\t返回</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"bfs广度优先搜索模板\"><a class=\"markdownIt-Anchor\" href=\"#bfs广度优先搜索模板\"></a> BFS（广度优先搜索）模板</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(队列判空)&#123;</span><br><span class=\"line\">\t取队头</span><br><span class=\"line\">\t删队头</span><br><span class=\"line\">\t标记</span><br><span class=\"line\">\t枚举位置的所有可能情况&#123;</span><br><span class=\"line\">\t\t判断</span><br><span class=\"line\">\t\t入队</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"strcmp\"><a class=\"markdownIt-Anchor\" href=\"#strcmp\"></a> strcmp()</h4>\n<code>strcmp(S1,S2)</code>可以判断两个字符串（在这是S1和S2）是否一致</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"map\"><a class=\"markdownIt-Anchor\" href=\"#map\"></a> map</h4>\n<p>**概念：**map以&lt;key,value&gt;键值对的形式存储，且map的内部自建一个红黑树，使得其可以自动排序。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li>\n<li>第二个可以称为该关键字的值(value)；</li>\n<li>key既不能重复也不能被修改</li>\n</ul>\n<p>**用处：**map在做数据映射的时候能够非常简便的完成代码构建，并且保持查询高效。</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmap&lt;string,<span class=\"type\">int</span>&gt; a; <span class=\"comment\">//第一个表示key数据类型，第二个表示value数据类型</span></span><br><span class=\"line\">    a[<span class=\"string\">&quot;one&quot;</span>] = <span class=\"number\">1</span>; </span><br><span class=\"line\">    a[<span class=\"string\">&quot;tow&quot;</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a[<span class=\"string\">&quot;one&quot;</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"comment\">//赋值时，key值作为下标，后面的数据作为对应key的value元素，在map中新添加一对数据</span></span><br><span class=\"line\">    <span class=\"comment\">//赋值时，如果key值已经存在，表示将此key值对应的value元素修改为新的数据</span></span><br><span class=\"line\">    cout &lt;&lt; a[<span class=\"string\">&quot;one&quot;</span>] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">//key值可以作为下标，直接输出对应的元素</span></span><br><span class=\"line\">    cout &lt;&lt; a[<span class=\"string\">&quot;three&quot;</span>] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">//注意：下标访问不会做下标检查，如上语句不会报错，但打印结果为空，因为下标访问会插入不存在的key，对应的value为默认值</span></span><br><span class=\"line\">    a.<span class=\"built_in\">insert</span>(&#123;<span class=\"string\">&quot;three&quot;</span>,<span class=\"number\">3</span>&#125;); <span class=\"comment\">//将指定键值对插入到map中，插入元素会自动插入到合适的位置，使整个map有序，默认是按照key从小到大排序</span></span><br><span class=\"line\">    a.<span class=\"built_in\">erase</span>(<span class=\"string\">&quot;one&quot;</span>); <span class=\"comment\">//删除指定key值的键值对</span></span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">count</span>(<span class=\"string\">&quot;three&quot;</span>) &lt;&lt; endl; <span class=\"comment\">//查询指定key值是否出现</span></span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">empty</span>() &lt;&lt; endl; <span class=\"comment\">//判断是否为空，非空为0，空为1 </span></span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">size</span>() &lt;&lt; endl; <span class=\"comment\">//获取map长度</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    map&lt;string,<span class=\"type\">int</span>&gt;::iterator it = a.<span class=\"built_in\">begin</span>(); <span class=\"comment\">//创建一个map类型迭代器  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;it!=a.<span class=\"built_in\">end</span>();it++)&#123;</span><br><span class=\"line\">    \tcout &lt;&lt; it-&gt;first &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; <span class=\"comment\">//遍历并输出，因为是类结构体指针，每个键值对通过first访问key，second访问value</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"set\"><a class=\"markdownIt-Anchor\" href=\"#set\"></a> set</h4>\n<p>**概念：**set里面每个元素只存有一个key，它支持高效的关键字查询操作。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>储存同一类型的数据元素（这点和vector、queue等其他容器相同）</li>\n<li>每个元素的值都唯一（没有重复的元素）</li>\n<li>根据元素的值自动排列大小（有序性）</li>\n<li>无法直接修改元素</li>\n<li>高效的插入删除操作</li>\n</ul>\n<p>**用处：**set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tset&lt;<span class=\"type\">int</span>&gt; a; <span class=\"comment\">//定义一个集合</span></span><br><span class=\"line\">    <span class=\"type\">int</span> arr[<span class=\"number\">5</span>]= &#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">13</span>,<span class=\"number\">19</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\">set&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">b</span><span class=\"params\">(arr,arr<span class=\"number\">+5</span>)</span></span>; <span class=\"comment\">//定义并初始化集合元素从数组arr中获取</span></span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt;::iterator it = b.<span class=\"built_in\">begin</span>(); <span class=\"comment\">//创建一个set类型迭代器</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;it!=b.<span class=\"built_in\">end</span>();it++)&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; *it &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; <span class=\"comment\">//遍历并输出</span></span><br><span class=\"line\">    cout &lt;&lt; b.<span class=\"built_in\">empty</span>() &lt;&lt; endl; <span class=\"comment\">//判断是否为空，非空为0，空为1 </span></span><br><span class=\"line\">    cout &lt;&lt; b.<span class=\"built_in\">size</span>() &lt;&lt; endl; <span class=\"comment\">//获取集合长度</span></span><br><span class=\"line\">    cout &lt;&lt; b.<span class=\"built_in\">count</span>(<span class=\"number\">13</span>) &lt;&lt; endl; <span class=\"comment\">//统计集合中指定元素出现的次数 </span></span><br><span class=\"line\">    b.<span class=\"built_in\">insert</span>(<span class=\"number\">8</span>); <span class=\"comment\">//将指定元素插入到集合中，插入元素会自动插入到合适的位置，使整个集合有序</span></span><br><span class=\"line\">    b.<span class=\"built_in\">erase</span>(<span class=\"number\">13</span>);<span class=\"comment\">//删除指定的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"栈\"><a class=\"markdownIt-Anchor\" href=\"#栈\"></a> 栈</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//栈:1、先进后出</span></span><br><span class=\"line\"><span class=\"comment\">//2、只能从一端进出，另一端封闭</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">push</span>();<span class=\"comment\">//往栈里添加一个元素 (进栈、入栈、压栈) </span></span><br><span class=\"line\"><span class=\"built_in\">pop</span>();<span class=\"comment\">//从栈顶删除一个元素 (出栈、弹栈)</span></span><br><span class=\"line\"><span class=\"built_in\">top</span>();<span class=\"comment\">//访问栈顶元素</span></span><br><span class=\"line\"><span class=\"built_in\">empty</span>();<span class=\"comment\">//判断栈是否为空，如果为空 1</span></span><br><span class=\"line\"><span class=\"built_in\">size</span>();<span class=\"comment\">//获取栈中元素的个数</span></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"队列所有\"><a class=\"markdownIt-Anchor\" href=\"#队列所有\"></a> 队列（所有）</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span><span class=\"comment\">//头文件</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;deque&gt;</span><span class=\"comment\">//双端队列头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//队列:1、先进先出</span></span><br><span class=\"line\"><span class=\"comment\">//2、从一端进，另一端出</span></span><br><span class=\"line\"><span class=\"comment\">//进数据的一端：队尾</span></span><br><span class=\"line\"><span class=\"comment\">//出数据的一端：队首</span></span><br><span class=\"line\"><span class=\"comment\">//双端队列除外</span></span><br><span class=\"line\"></span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;<span class=\"comment\">//正常队列</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>&gt; q;<span class=\"comment\">//优先队列，默认优先级从大到小，用法见栈</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>,vector&lt;<span class=\"type\">int</span>&gt;,greater&lt;<span class=\"type\">int</span>&gt; &gt; q;<span class=\"comment\">//优先级从小到大</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>,vector&lt;<span class=\"type\">int</span>&gt;,less&lt;<span class=\"type\">int</span>&gt; &gt; q;<span class=\"comment\">//优先级从大到小</span></span><br><span class=\"line\">deque&lt;<span class=\"type\">int</span>&gt; que;<span class=\"comment\">//双端队列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">push</span>();<span class=\"comment\">//从队尾添加一个元素 (入队)</span></span><br><span class=\"line\"><span class=\"built_in\">push_front</span>();<span class=\"comment\">//从队首添加一个元素 (入队)。（对于双端队列）</span></span><br><span class=\"line\"><span class=\"built_in\">push_back</span>();<span class=\"comment\">//从队尾添加一个元素 (入队)。（对于双端队列）</span></span><br><span class=\"line\">que[<span class=\"number\">1</span>];<span class=\"comment\">//下标访问（并不会检查是否越界）。（对于双端队列）</span></span><br><span class=\"line\"><span class=\"built_in\">pop</span>();<span class=\"comment\">//从队首删除一个元素 （）出队）。</span></span><br><span class=\"line\"><span class=\"built_in\">pop_front</span>();<span class=\"comment\">//删除队首元素（出队）。（对于双端队列）</span></span><br><span class=\"line\"><span class=\"built_in\">pop_back</span>();<span class=\"comment\">//删除队尾元素（出队）。（对于双端队列）</span></span><br><span class=\"line\"><span class=\"built_in\">front</span>();<span class=\"comment\">//访问队首元素。</span></span><br><span class=\"line\"><span class=\"built_in\">back</span>();<span class=\"comment\">//访问队尾元素。</span></span><br><span class=\"line\"><span class=\"built_in\">empty</span>();<span class=\"comment\">//判断栈是否为空，如果为空 1。</span></span><br><span class=\"line\"><span class=\"built_in\">size</span>();<span class=\"comment\">//获取栈中元素的个数。</span></span><br><span class=\"line\">que.<span class=\"built_in\">clear</span>();<span class=\"comment\">//清空所有元素。</span></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"快读快写\"><a class=\"markdownIt-Anchor\" href=\"#快读快写\"></a> 快读快写</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;  <span class=\"comment\">//快读，用getchar()来代替输入</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> w=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(ch&lt;<span class=\"number\">48</span>||ch&gt;<span class=\"number\">57</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ch==<span class=\"number\">45</span>) w=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">while</span>(ch&gt;<span class=\"number\">47</span>&amp;&amp;ch&lt;<span class=\"number\">58</span>)&#123;</span><br><span class=\"line\">\t\tx=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(ch^<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\tch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> w?x:(-x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;  <span class=\"comment\">//快写，用putchar()</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(<span class=\"number\">45</span>);</span><br><span class=\"line\">\t\tx=-x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x&gt;<span class=\"number\">9</span>) <span class=\"built_in\">write</span>(x/<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">putchar</span>(x%<span class=\"number\">10</span><span class=\"number\">+48</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> k = <span class=\"built_in\">read</span>(); <span class=\"comment\">//输入</span></span><br><span class=\"line\">   <span class=\"built_in\">write</span>(k); <span class=\"comment\">//输出</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"freopen\"><a class=\"markdownIt-Anchor\" href=\"#freopen\"></a> freopen()</h4>\n</li>\n</ul>\n<p>**作用：**重定向标准输入或输出</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;文件名&quot;</span>,<span class=\"string\">&quot;读或写（r或w）&quot;</span>,重定向标准输入还是输出（stdin还是stdout）);</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"vecotor动态数组\"><a class=\"markdownIt-Anchor\" href=\"#vecotor动态数组\"></a> vecotor（动态数组）</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v1;<span class=\"comment\">//创建一个空的动态数组</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;<span class=\"comment\">//创建一个空间为10的动态数组，元素默认值为0</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v3</span><span class=\"params\">(<span class=\"number\">5</span>,<span class=\"number\">3</span>)</span></span>;<span class=\"comment\">//创建一个空间为5的动态数组，元素默认值为3</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v4</span><span class=\"params\">(v3)</span></span>;<span class=\"comment\">//创建一个动态数组，其内容拷贝v3</span></span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">100</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v5</span><span class=\"params\">(a, a<span class=\"number\">+5</span>)</span></span>;<span class=\"comment\">//拷贝数组a[0]~a[4]的元素到动态数组v5中</span></span><br><span class=\"line\"></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">push_back</span>(x);<span class=\"comment\">//在动态数组v1最后添加一个元素x</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">pop_back</span>();<span class=\"comment\">//删除动态数组v1最后一个元素</span></span><br><span class=\"line\">v<span class=\"number\">1.f</span>ront();<span class=\"comment\">//访问(获取)动态数组v1第一个元素</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">back</span>();<span class=\"comment\">//访问(获取)动态数组v1最后一个元素</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">erase</span>(x);<span class=\"comment\">//删除指定位置的元素，x是一个迭代器</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">begin</span>();<span class=\"comment\">//获取动态数组第一个元素的迭代器</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">end</span>()<span class=\"number\">-1</span>;<span class=\"comment\">//获取动态数组最后一个元素的迭代器</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">size</span>();<span class=\"comment\">//获取动态数组中的元素个数</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">empty</span>();<span class=\"comment\">//判空</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">clear</span>();<span class=\"comment\">//清空动态数组</span></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"pair\"><a class=\"markdownIt-Anchor\" href=\"#pair\"></a> pair</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;<span class=\"comment\">//pair有且只有2个元素</span></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"dijkstra最短路径图算法\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra最短路径图算法\"></a> dijkstra最短路径（图）算法</h4>\n<p>**时间复杂度：**O(n^2)<br />\n**限制：**只能解决无负权、单源（单一源头）的图的问题<br />\n**特点：**dis数组中的最小值一定为最短路<br />\n<strong>tips</strong>：<a href=\"#dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%AE%97%E6%B3%95%E5%A0%86%E4%BC%98%E5%8C%96\">堆优化版本</a>时间复杂度更小，特点、限制一样</p>\n<p><strong>伪代码</strong>：</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tdis初始化为inf，dis[起点] 设为<span class=\"number\">0</span></span><br><span class=\"line\">\tvis初始化为<span class=\"number\">0</span></span><br><span class=\"line\">\t循环顶点次数：</span><br><span class=\"line\">\t\t<span class=\"number\">1.</span> 循环查找dis数组中 *未被标记的* 最小值及其位置 pos</span><br><span class=\"line\">\t\t<span class=\"number\">2.</span> 用vis标记pos点</span><br><span class=\"line\">\t\t<span class=\"number\">3.</span> 枚举pos为起点的所有边，更新总起点到这些边的终点的dis值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>**代码**：\n</code></pre>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;++i) dis[i]=<span class=\"number\">1e8</span>;</span><br><span class=\"line\">\tdis[a]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;++j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!(vis[j])) pos=(dis[pos]&lt;dis[j]?pos:j);</span><br><span class=\"line\">\t\tvis[pos]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; x : gh[pos])</span><br><span class=\"line\">\t\t\tdis[x.first]=<span class=\"built_in\">min</span>(dis[x.first],dis[pos]+x.second);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"dijkstra最短路径图算法堆优化\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra最短路径图算法堆优化\"></a> dijkstra最短路径（图）算法（堆优化）</h4>\n<p>**时间复杂度：**O((m+n)× log(n))<br />\n**限制 &amp; 特点：**同<a href=\"#dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%AE%97%E6%B3%95\">优化前</a></p>\n<p><strong>伪代码</strong>：</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tdis初始化为inf，dis[起点] 设为<span class=\"number\">0</span></span><br><span class=\"line\">\tvis初始化为<span class=\"number\">0</span>，并起点入队</span><br><span class=\"line\">\t循环顶点次数：</span><br><span class=\"line\">\t\t<span class=\"number\">1.</span> 出队找最小值</span><br><span class=\"line\">\t\t<span class=\"number\">2.</span> 如果tmp.pos被标记 <span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t<span class=\"number\">3.</span> 用vis标记pos点</span><br><span class=\"line\">\t\t<span class=\"number\">4.</span> 枚举pos为起点的所有边，更新总起点到这些边的终点的dis值</span><br><span class=\"line\">\t\t\t特别注意判断终点是否有被标记</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>**代码**：\n</code></pre>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pos,dis;</span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(Node a,Node b)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a.dis&gt;b.dis;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">               </span><br><span class=\"line\">vector&lt; pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt; gh[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a,dis[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">100005</span>];</span><br><span class=\"line\">priority_queue&lt;Node&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;++i) dis[i]=<span class=\"number\">1e9</span><span class=\"number\">+5</span>;</span><br><span class=\"line\">\tdis[a]=<span class=\"number\">0</span>,q.<span class=\"built_in\">push</span>(&#123;a,<span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">\t\tNode tmp=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(vis[tmp.pos]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tvis[tmp.pos]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; x : gh[tmp.pos])&#123;</span><br><span class=\"line\">\t\t\tdis[x.first]=<span class=\"built_in\">min</span>(dis[x.first],dis[tmp.pos]+x.second);</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">push</span>(&#123;x.first,dis[x.first]&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"top拓扑排序\"><a class=\"markdownIt-Anchor\" href=\"#top拓扑排序\"></a> top（拓扑排序）</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; mp[<span class=\"number\">100005</span>], tp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">top</span><span class=\"params\">( <span class=\"type\">int</span> n, <span class=\"type\">int</span> m, <span class=\"type\">int</span>* du )</span></span>&#123;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( <span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; ++i ) <span class=\"keyword\">if</span>(du[i]==<span class=\"number\">0</span>) st.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>( st.<span class=\"built_in\">size</span>() )&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tmp = st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\ttp.<span class=\"built_in\">push_back</span>(tmp);</span><br><span class=\"line\">\t\tst.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>( <span class=\"type\">int</span> node : mp[tmp] )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(--du[node]==<span class=\"number\">0</span>) st.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt==n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n, m, du[<span class=\"number\">100005</span>]=&#123;&#125;,v1,v2;</span><br><span class=\"line\">\tcin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( <span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; ++i )&#123;</span><br><span class=\"line\">\t\tcin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class=\"line\">\t\tdu[v2]++;</span><br><span class=\"line\">\t\tmp[v1].<span class=\"built_in\">push_back</span>(v2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( <span class=\"built_in\">top</span>(n,m,du) )</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>( <span class=\"type\">int</span> x:tp ) cout &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout &lt;&lt; <span class=\"string\">&quot; has cicle&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"floyd最短路径图算法\"><a class=\"markdownIt-Anchor\" href=\"#floyd最短路径图算法\"></a> Floyd最短路径（图）算法</h4>\n<p>**时间复杂度：**O(n^3)<br />\n**限制：**可解决有负权、多源（多源头）的图的问题<br />\n**特征：**dp数组（没错，是动态规划）中的最小值一定为最短路</p>\n<p>伪代码：</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (中转点 k) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (起点 i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (终点 j) &#123;</span><br><span class=\"line\">\t\t\tdp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>代码：\n</code></pre>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> dp[<span class=\"number\">105</span>][<span class=\"number\">105</span>], n, m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dp, <span class=\"number\">0x3f</span>, <span class=\"built_in\">sizeof</span>(dp));<span class=\"comment\">//dp数组每个字节填充0x3f</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) dp[i][i] = <span class=\"number\">0</span>;<span class=\"comment\">//dp数组对角线（i=j）填充0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> v1, v2, w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;v1, &amp;v2, &amp;w);</span><br><span class=\"line\">\t\t<span class=\"comment\">//赋值并避免重边</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dp[v1][v2] &gt; w) dp[v1][v2] = dp[v2][v1] = w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//动规</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">\t\t\t\tdp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class=\"line\">\t<span class=\"comment\">//输出</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, dp[i][j]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<div class=\"title\">\n此笔记由我在学习过程中编写，不保证准确性和完整性，如有错误请指出。\n另外，该笔记的分类和样式有部分很奇怪，我正在尽力处理此事情，请见谅。\n</div>\n---\n- #### 线性筛 & 埃氏筛\n\t**埃氏筛（伪代码）：**\n\t<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">遍历：</span><br><span class=\"line\">    若为没被标记，则从其本身开始标记其的整数倍；</span><br></pre></td></tr></table></figure>\n\t**线性筛（伪代码）:**\n\t<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">遍历：</span><br><span class=\"line\">    <span class=\"number\">1.</span> 若为没被标记，放入质数表；</span><br><span class=\"line\">    <span class=\"number\">2.</span> 枚举质数表中的数：</span><br><span class=\"line\">        <span class=\"number\">2.1</span> 标记(枚举到的数*枚举到的质数)</span><br><span class=\"line\">        <span class=\"number\">2.2</span> 若枚举到的数为枚举到的质数的整数倍，则退出循环</span><br></pre></td></tr></table></figure>\n---\n- #### 分治\n\t- **概念：** 将一大任务分成两个近似的较小任务解决，最后再合并（类似递归）。若平均分后仍无法解决，则继续分。\n\t- **典型例子：**\n\t\t1. 快速排序（伪代码）：\n\t\t<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 先随机找一个参照值，去应为小的那边找比其大的（反之则找比其小的），并标记</span><br><span class=\"line\"><span class=\"number\">2.</span> 将标记过的比其大的和比其小的交换</span><br><span class=\"line\"><span class=\"number\">3.</span> 再将数组分成两半，两半分别重复所有动作，直至仅剩一个元素</span><br></pre></td></tr></table></figure>\n\t\t2. 归并排序（伪代码）：\n\t\t<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 将数组分成两半，直至操作的那个数组仅剩一个元素</span><br><span class=\"line\"><span class=\"number\">2.</span> 跳回上一步，与上一步分出的另一个数组有序地合并（若另一个数组已执行了相同步骤，即其有序。若无序，则让另一个数组执行<span class=\"number\">1.</span> ）</span><br><span class=\"line\"><span class=\"number\">3.</span> 重复执行<span class=\"number\">2.</span> ，直至有序</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\"></a> 链表</h4>\n<strong>：</strong></li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"二分\"><a class=\"markdownIt-Anchor\" href=\"#二分\"></a> 二分</h4>\n<strong>找最前面的该数代码：</strong>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a_y[mid] &gt;= a_x[i]) r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">注意：l为这个数</span><br></pre></td></tr></table></figure>\n<strong>找最后面的该数代码：</strong>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a_y[mid] &gt; a_x[i]) r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">注意：l为其下表<span class=\"number\">+1</span>的数</span><br></pre></td></tr></table></figure>\n**重点注意：**若没找到，r和l分别为其左右最接近的数</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"sizeof\"><a class=\"markdownIt-Anchor\" href=\"#sizeof\"></a> sizeof()</h4>\n<p><code>sizeof(对象)</code>可以求一个对象所占的字节数</p>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"memset\"><a class=\"markdownIt-Anchor\" href=\"#memset\"></a> memset()</h4>\n<p><code>memset( 对象 , 要成初始化的数 , 初始化的字节数 )</code>可以初始化一个对象的几个字节为同一个数</p>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"指针\"><a class=\"markdownIt-Anchor\" href=\"#指针\"></a> 指针</h4>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> *p=&amp;a;<span class=\"comment\">//指针变量p存储变量a的地址</span></span><br><span class=\"line\">*p<span class=\"comment\">//解引用：在这是表示指针变量p所存的地址的值</span></span><br><span class=\"line\"><span class=\"type\">int</span> b=&amp;a;<span class=\"comment\">//引用：在这是将变量b本身的地址设为变量a本身的地址（他们用同一个地址）</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"结构体\"><a class=\"markdownIt-Anchor\" href=\"#结构体\"></a> 结构体</h4>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">a</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(Node a,Node b)&#123;<span class=\"comment\">//该结构体的朋友函数</span></span><br><span class=\"line\"><span class=\"comment\">//“operator&lt;”为重定义运算符“&lt;”</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a.dis&gt;b.dis;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//该做法可用于在优先队列中使用结构体的情况。</span></span><br><span class=\"line\">&#125;x;<span class=\"comment\">//可直接在这此这样定义</span></span><br><span class=\"line\">a x;<span class=\"comment\">//也可这样定义</span></span><br><span class=\"line\">&amp;x<span class=\"comment\">//为该结构体第一项的地址（数组也同样）</span></span><br><span class=\"line\">&amp;x+n<span class=\"comment\">//为该结构体第1+n项的地址（数组也同样）</span></span><br><span class=\"line\">x<span class=\"comment\">//该结构体的第一项（数组也同样）</span></span><br><span class=\"line\">x+n<span class=\"comment\">//为该结构体第1+n项的地址（数组也同样）</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"const\"><a class=\"markdownIt-Anchor\" href=\"#const\"></a> const</h4>\n<p><code>const</code>是常量修饰符，被它修饰的变量在初始化后无法被修改</p>\n</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"dfs深度优先搜索模板\"><a class=\"markdownIt-Anchor\" href=\"#dfs深度优先搜索模板\"></a> DFS（深度优先搜索）模板</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">( <span class=\"type\">int</span> pos )</span></span>&#123;</span><br><span class=\"line\">\t判断终点</span><br><span class=\"line\">\t\t处理数据</span><br><span class=\"line\">\t\t返回</span><br><span class=\"line\">\t枚举pos位置的所有可能情况:</span><br><span class=\"line\">\t\t判断</span><br><span class=\"line\">\t\t给pos位置赋值</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>()搜索下一个位置</span><br><span class=\"line\">\t返回</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"bfs广度优先搜索模板\"><a class=\"markdownIt-Anchor\" href=\"#bfs广度优先搜索模板\"></a> BFS（广度优先搜索）模板</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(队列判空)&#123;</span><br><span class=\"line\">\t取队头</span><br><span class=\"line\">\t删队头</span><br><span class=\"line\">\t标记</span><br><span class=\"line\">\t枚举位置的所有可能情况&#123;</span><br><span class=\"line\">\t\t判断</span><br><span class=\"line\">\t\t入队</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"strcmp\"><a class=\"markdownIt-Anchor\" href=\"#strcmp\"></a> strcmp()</h4>\n<code>strcmp(S1,S2)</code>可以判断两个字符串（在这是S1和S2）是否一致</li>\n</ul>\n<hr />\n<ul>\n<li>\n<h4 id=\"map\"><a class=\"markdownIt-Anchor\" href=\"#map\"></a> map</h4>\n<p>**概念：**map以&lt;key,value&gt;键值对的形式存储，且map的内部自建一个红黑树，使得其可以自动排序。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li>\n<li>第二个可以称为该关键字的值(value)；</li>\n<li>key既不能重复也不能被修改</li>\n</ul>\n<p>**用处：**map在做数据映射的时候能够非常简便的完成代码构建，并且保持查询高效。</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmap&lt;string,<span class=\"type\">int</span>&gt; a; <span class=\"comment\">//第一个表示key数据类型，第二个表示value数据类型</span></span><br><span class=\"line\">    a[<span class=\"string\">&quot;one&quot;</span>] = <span class=\"number\">1</span>; </span><br><span class=\"line\">    a[<span class=\"string\">&quot;tow&quot;</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a[<span class=\"string\">&quot;one&quot;</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"comment\">//赋值时，key值作为下标，后面的数据作为对应key的value元素，在map中新添加一对数据</span></span><br><span class=\"line\">    <span class=\"comment\">//赋值时，如果key值已经存在，表示将此key值对应的value元素修改为新的数据</span></span><br><span class=\"line\">    cout &lt;&lt; a[<span class=\"string\">&quot;one&quot;</span>] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">//key值可以作为下标，直接输出对应的元素</span></span><br><span class=\"line\">    cout &lt;&lt; a[<span class=\"string\">&quot;three&quot;</span>] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">//注意：下标访问不会做下标检查，如上语句不会报错，但打印结果为空，因为下标访问会插入不存在的key，对应的value为默认值</span></span><br><span class=\"line\">    a.<span class=\"built_in\">insert</span>(&#123;<span class=\"string\">&quot;three&quot;</span>,<span class=\"number\">3</span>&#125;); <span class=\"comment\">//将指定键值对插入到map中，插入元素会自动插入到合适的位置，使整个map有序，默认是按照key从小到大排序</span></span><br><span class=\"line\">    a.<span class=\"built_in\">erase</span>(<span class=\"string\">&quot;one&quot;</span>); <span class=\"comment\">//删除指定key值的键值对</span></span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">count</span>(<span class=\"string\">&quot;three&quot;</span>) &lt;&lt; endl; <span class=\"comment\">//查询指定key值是否出现</span></span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">empty</span>() &lt;&lt; endl; <span class=\"comment\">//判断是否为空，非空为0，空为1 </span></span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">size</span>() &lt;&lt; endl; <span class=\"comment\">//获取map长度</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    map&lt;string,<span class=\"type\">int</span>&gt;::iterator it = a.<span class=\"built_in\">begin</span>(); <span class=\"comment\">//创建一个map类型迭代器  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;it!=a.<span class=\"built_in\">end</span>();it++)&#123;</span><br><span class=\"line\">    \tcout &lt;&lt; it-&gt;first &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; <span class=\"comment\">//遍历并输出，因为是类结构体指针，每个键值对通过first访问key，second访问value</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"set\"><a class=\"markdownIt-Anchor\" href=\"#set\"></a> set</h4>\n<p>**概念：**set里面每个元素只存有一个key，它支持高效的关键字查询操作。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>储存同一类型的数据元素（这点和vector、queue等其他容器相同）</li>\n<li>每个元素的值都唯一（没有重复的元素）</li>\n<li>根据元素的值自动排列大小（有序性）</li>\n<li>无法直接修改元素</li>\n<li>高效的插入删除操作</li>\n</ul>\n<p>**用处：**set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tset&lt;<span class=\"type\">int</span>&gt; a; <span class=\"comment\">//定义一个集合</span></span><br><span class=\"line\">    <span class=\"type\">int</span> arr[<span class=\"number\">5</span>]= &#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">13</span>,<span class=\"number\">19</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\">set&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">b</span><span class=\"params\">(arr,arr<span class=\"number\">+5</span>)</span></span>; <span class=\"comment\">//定义并初始化集合元素从数组arr中获取</span></span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt;::iterator it = b.<span class=\"built_in\">begin</span>(); <span class=\"comment\">//创建一个set类型迭代器</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;it!=b.<span class=\"built_in\">end</span>();it++)&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; *it &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; <span class=\"comment\">//遍历并输出</span></span><br><span class=\"line\">    cout &lt;&lt; b.<span class=\"built_in\">empty</span>() &lt;&lt; endl; <span class=\"comment\">//判断是否为空，非空为0，空为1 </span></span><br><span class=\"line\">    cout &lt;&lt; b.<span class=\"built_in\">size</span>() &lt;&lt; endl; <span class=\"comment\">//获取集合长度</span></span><br><span class=\"line\">    cout &lt;&lt; b.<span class=\"built_in\">count</span>(<span class=\"number\">13</span>) &lt;&lt; endl; <span class=\"comment\">//统计集合中指定元素出现的次数 </span></span><br><span class=\"line\">    b.<span class=\"built_in\">insert</span>(<span class=\"number\">8</span>); <span class=\"comment\">//将指定元素插入到集合中，插入元素会自动插入到合适的位置，使整个集合有序</span></span><br><span class=\"line\">    b.<span class=\"built_in\">erase</span>(<span class=\"number\">13</span>);<span class=\"comment\">//删除指定的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"栈\"><a class=\"markdownIt-Anchor\" href=\"#栈\"></a> 栈</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//栈:1、先进后出</span></span><br><span class=\"line\"><span class=\"comment\">//2、只能从一端进出，另一端封闭</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">push</span>();<span class=\"comment\">//往栈里添加一个元素 (进栈、入栈、压栈) </span></span><br><span class=\"line\"><span class=\"built_in\">pop</span>();<span class=\"comment\">//从栈顶删除一个元素 (出栈、弹栈)</span></span><br><span class=\"line\"><span class=\"built_in\">top</span>();<span class=\"comment\">//访问栈顶元素</span></span><br><span class=\"line\"><span class=\"built_in\">empty</span>();<span class=\"comment\">//判断栈是否为空，如果为空 1</span></span><br><span class=\"line\"><span class=\"built_in\">size</span>();<span class=\"comment\">//获取栈中元素的个数</span></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"队列所有\"><a class=\"markdownIt-Anchor\" href=\"#队列所有\"></a> 队列（所有）</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span><span class=\"comment\">//头文件</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;deque&gt;</span><span class=\"comment\">//双端队列头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//队列:1、先进先出</span></span><br><span class=\"line\"><span class=\"comment\">//2、从一端进，另一端出</span></span><br><span class=\"line\"><span class=\"comment\">//进数据的一端：队尾</span></span><br><span class=\"line\"><span class=\"comment\">//出数据的一端：队首</span></span><br><span class=\"line\"><span class=\"comment\">//双端队列除外</span></span><br><span class=\"line\"></span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;<span class=\"comment\">//正常队列</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>&gt; q;<span class=\"comment\">//优先队列，默认优先级从大到小，用法见栈</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>,vector&lt;<span class=\"type\">int</span>&gt;,greater&lt;<span class=\"type\">int</span>&gt; &gt; q;<span class=\"comment\">//优先级从小到大</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>,vector&lt;<span class=\"type\">int</span>&gt;,less&lt;<span class=\"type\">int</span>&gt; &gt; q;<span class=\"comment\">//优先级从大到小</span></span><br><span class=\"line\">deque&lt;<span class=\"type\">int</span>&gt; que;<span class=\"comment\">//双端队列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">push</span>();<span class=\"comment\">//从队尾添加一个元素 (入队)</span></span><br><span class=\"line\"><span class=\"built_in\">push_front</span>();<span class=\"comment\">//从队首添加一个元素 (入队)。（对于双端队列）</span></span><br><span class=\"line\"><span class=\"built_in\">push_back</span>();<span class=\"comment\">//从队尾添加一个元素 (入队)。（对于双端队列）</span></span><br><span class=\"line\">que[<span class=\"number\">1</span>];<span class=\"comment\">//下标访问（并不会检查是否越界）。（对于双端队列）</span></span><br><span class=\"line\"><span class=\"built_in\">pop</span>();<span class=\"comment\">//从队首删除一个元素 （）出队）。</span></span><br><span class=\"line\"><span class=\"built_in\">pop_front</span>();<span class=\"comment\">//删除队首元素（出队）。（对于双端队列）</span></span><br><span class=\"line\"><span class=\"built_in\">pop_back</span>();<span class=\"comment\">//删除队尾元素（出队）。（对于双端队列）</span></span><br><span class=\"line\"><span class=\"built_in\">front</span>();<span class=\"comment\">//访问队首元素。</span></span><br><span class=\"line\"><span class=\"built_in\">back</span>();<span class=\"comment\">//访问队尾元素。</span></span><br><span class=\"line\"><span class=\"built_in\">empty</span>();<span class=\"comment\">//判断栈是否为空，如果为空 1。</span></span><br><span class=\"line\"><span class=\"built_in\">size</span>();<span class=\"comment\">//获取栈中元素的个数。</span></span><br><span class=\"line\">que.<span class=\"built_in\">clear</span>();<span class=\"comment\">//清空所有元素。</span></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"快读快写\"><a class=\"markdownIt-Anchor\" href=\"#快读快写\"></a> 快读快写</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;  <span class=\"comment\">//快读，用getchar()来代替输入</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> w=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(ch&lt;<span class=\"number\">48</span>||ch&gt;<span class=\"number\">57</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ch==<span class=\"number\">45</span>) w=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">while</span>(ch&gt;<span class=\"number\">47</span>&amp;&amp;ch&lt;<span class=\"number\">58</span>)&#123;</span><br><span class=\"line\">\t\tx=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(ch^<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\tch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> w?x:(-x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;  <span class=\"comment\">//快写，用putchar()</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(<span class=\"number\">45</span>);</span><br><span class=\"line\">\t\tx=-x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x&gt;<span class=\"number\">9</span>) <span class=\"built_in\">write</span>(x/<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">putchar</span>(x%<span class=\"number\">10</span><span class=\"number\">+48</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> k = <span class=\"built_in\">read</span>(); <span class=\"comment\">//输入</span></span><br><span class=\"line\">   <span class=\"built_in\">write</span>(k); <span class=\"comment\">//输出</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"freopen\"><a class=\"markdownIt-Anchor\" href=\"#freopen\"></a> freopen()</h4>\n</li>\n</ul>\n<p>**作用：**重定向标准输入或输出</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;文件名&quot;</span>,<span class=\"string\">&quot;读或写（r或w）&quot;</span>,重定向标准输入还是输出（stdin还是stdout）);</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"vecotor动态数组\"><a class=\"markdownIt-Anchor\" href=\"#vecotor动态数组\"></a> vecotor（动态数组）</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v1;<span class=\"comment\">//创建一个空的动态数组</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;<span class=\"comment\">//创建一个空间为10的动态数组，元素默认值为0</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v3</span><span class=\"params\">(<span class=\"number\">5</span>,<span class=\"number\">3</span>)</span></span>;<span class=\"comment\">//创建一个空间为5的动态数组，元素默认值为3</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v4</span><span class=\"params\">(v3)</span></span>;<span class=\"comment\">//创建一个动态数组，其内容拷贝v3</span></span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">100</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v5</span><span class=\"params\">(a, a<span class=\"number\">+5</span>)</span></span>;<span class=\"comment\">//拷贝数组a[0]~a[4]的元素到动态数组v5中</span></span><br><span class=\"line\"></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">push_back</span>(x);<span class=\"comment\">//在动态数组v1最后添加一个元素x</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">pop_back</span>();<span class=\"comment\">//删除动态数组v1最后一个元素</span></span><br><span class=\"line\">v<span class=\"number\">1.f</span>ront();<span class=\"comment\">//访问(获取)动态数组v1第一个元素</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">back</span>();<span class=\"comment\">//访问(获取)动态数组v1最后一个元素</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">erase</span>(x);<span class=\"comment\">//删除指定位置的元素，x是一个迭代器</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">begin</span>();<span class=\"comment\">//获取动态数组第一个元素的迭代器</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">end</span>()<span class=\"number\">-1</span>;<span class=\"comment\">//获取动态数组最后一个元素的迭代器</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">size</span>();<span class=\"comment\">//获取动态数组中的元素个数</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">empty</span>();<span class=\"comment\">//判空</span></span><br><span class=\"line\">v<span class=\"number\">1.</span><span class=\"built_in\">clear</span>();<span class=\"comment\">//清空动态数组</span></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"pair\"><a class=\"markdownIt-Anchor\" href=\"#pair\"></a> pair</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;<span class=\"comment\">//pair有且只有2个元素</span></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"dijkstra最短路径图算法\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra最短路径图算法\"></a> dijkstra最短路径（图）算法</h4>\n<p>**时间复杂度：**O(n^2)<br />\n**限制：**只能解决无负权、单源（单一源头）的图的问题<br />\n**特点：**dis数组中的最小值一定为最短路<br />\n<strong>tips</strong>：<a href=\"#dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%AE%97%E6%B3%95%E5%A0%86%E4%BC%98%E5%8C%96\">堆优化版本</a>时间复杂度更小，特点、限制一样</p>\n<p><strong>伪代码</strong>：</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tdis初始化为inf，dis[起点] 设为<span class=\"number\">0</span></span><br><span class=\"line\">\tvis初始化为<span class=\"number\">0</span></span><br><span class=\"line\">\t循环顶点次数：</span><br><span class=\"line\">\t\t<span class=\"number\">1.</span> 循环查找dis数组中 *未被标记的* 最小值及其位置 pos</span><br><span class=\"line\">\t\t<span class=\"number\">2.</span> 用vis标记pos点</span><br><span class=\"line\">\t\t<span class=\"number\">3.</span> 枚举pos为起点的所有边，更新总起点到这些边的终点的dis值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>**代码**：\n</code></pre>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;++i) dis[i]=<span class=\"number\">1e8</span>;</span><br><span class=\"line\">\tdis[a]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;++j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!(vis[j])) pos=(dis[pos]&lt;dis[j]?pos:j);</span><br><span class=\"line\">\t\tvis[pos]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; x : gh[pos])</span><br><span class=\"line\">\t\t\tdis[x.first]=<span class=\"built_in\">min</span>(dis[x.first],dis[pos]+x.second);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"dijkstra最短路径图算法堆优化\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra最短路径图算法堆优化\"></a> dijkstra最短路径（图）算法（堆优化）</h4>\n<p>**时间复杂度：**O((m+n)× log(n))<br />\n**限制 &amp; 特点：**同<a href=\"#dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%AE%97%E6%B3%95\">优化前</a></p>\n<p><strong>伪代码</strong>：</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tdis初始化为inf，dis[起点] 设为<span class=\"number\">0</span></span><br><span class=\"line\">\tvis初始化为<span class=\"number\">0</span>，并起点入队</span><br><span class=\"line\">\t循环顶点次数：</span><br><span class=\"line\">\t\t<span class=\"number\">1.</span> 出队找最小值</span><br><span class=\"line\">\t\t<span class=\"number\">2.</span> 如果tmp.pos被标记 <span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t<span class=\"number\">3.</span> 用vis标记pos点</span><br><span class=\"line\">\t\t<span class=\"number\">4.</span> 枚举pos为起点的所有边，更新总起点到这些边的终点的dis值</span><br><span class=\"line\">\t\t\t特别注意判断终点是否有被标记</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>**代码**：\n</code></pre>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pos,dis;</span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(Node a,Node b)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a.dis&gt;b.dis;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">               </span><br><span class=\"line\">vector&lt; pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt; gh[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a,dis[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">100005</span>];</span><br><span class=\"line\">priority_queue&lt;Node&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;++i) dis[i]=<span class=\"number\">1e9</span><span class=\"number\">+5</span>;</span><br><span class=\"line\">\tdis[a]=<span class=\"number\">0</span>,q.<span class=\"built_in\">push</span>(&#123;a,<span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">\t\tNode tmp=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(vis[tmp.pos]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tvis[tmp.pos]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; x : gh[tmp.pos])&#123;</span><br><span class=\"line\">\t\t\tdis[x.first]=<span class=\"built_in\">min</span>(dis[x.first],dis[tmp.pos]+x.second);</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">push</span>(&#123;x.first,dis[x.first]&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"top拓扑排序\"><a class=\"markdownIt-Anchor\" href=\"#top拓扑排序\"></a> top（拓扑排序）</h4>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; mp[<span class=\"number\">100005</span>], tp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">top</span><span class=\"params\">( <span class=\"type\">int</span> n, <span class=\"type\">int</span> m, <span class=\"type\">int</span>* du )</span></span>&#123;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( <span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; ++i ) <span class=\"keyword\">if</span>(du[i]==<span class=\"number\">0</span>) st.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>( st.<span class=\"built_in\">size</span>() )&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tmp = st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\ttp.<span class=\"built_in\">push_back</span>(tmp);</span><br><span class=\"line\">\t\tst.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>( <span class=\"type\">int</span> node : mp[tmp] )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(--du[node]==<span class=\"number\">0</span>) st.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt==n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n, m, du[<span class=\"number\">100005</span>]=&#123;&#125;,v1,v2;</span><br><span class=\"line\">\tcin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( <span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; ++i )&#123;</span><br><span class=\"line\">\t\tcin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class=\"line\">\t\tdu[v2]++;</span><br><span class=\"line\">\t\tmp[v1].<span class=\"built_in\">push_back</span>(v2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( <span class=\"built_in\">top</span>(n,m,du) )</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>( <span class=\"type\">int</span> x:tp ) cout &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout &lt;&lt; <span class=\"string\">&quot; has cicle&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<ul>\n<li>\n<h4 id=\"floyd最短路径图算法\"><a class=\"markdownIt-Anchor\" href=\"#floyd最短路径图算法\"></a> Floyd最短路径（图）算法</h4>\n<p>**时间复杂度：**O(n^3)<br />\n**限制：**可解决有负权、多源（多源头）的图的问题<br />\n**特征：**dp数组（没错，是动态规划）中的最小值一定为最短路</p>\n<p>伪代码：</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (中转点 k) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (起点 i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (终点 j) &#123;</span><br><span class=\"line\">\t\t\tdp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>代码：\n</code></pre>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> dp[<span class=\"number\">105</span>][<span class=\"number\">105</span>], n, m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dp, <span class=\"number\">0x3f</span>, <span class=\"built_in\">sizeof</span>(dp));<span class=\"comment\">//dp数组每个字节填充0x3f</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) dp[i][i] = <span class=\"number\">0</span>;<span class=\"comment\">//dp数组对角线（i=j）填充0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> v1, v2, w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;v1, &amp;v2, &amp;w);</span><br><span class=\"line\">\t\t<span class=\"comment\">//赋值并避免重边</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dp[v1][v2] &gt; w) dp[v1][v2] = dp[v2][v1] = w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//动规</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">\t\t\t\tdp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class=\"line\">\t<span class=\"comment\">//输出</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, dp[i][j]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","path":"2025/08/09/笔记/","permalink":"https://czihan-create.github.io/2025/08/09/%E7%AC%94%E8%AE%B0/","tags":[{"name":"笔记","_id":"cmeoactk400096zyq4ozn2eb2","slug":"笔记","path":"tags/笔记/","permalink":"https://czihan-create.github.io/tags/%E7%AC%94%E8%AE%B0/","length":3},{"name":"编程","_id":"cmeoactk6000b6zyqgrjkdp3y","slug":"编程","path":"tags/编程/","permalink":"https://czihan-create.github.io/tags/%E7%BC%96%E7%A8%8B/","length":2},{"name":"日常记录","_id":"cmeoactk7000e6zyqgdyoc1bj","slug":"日常记录","path":"tags/日常记录/","permalink":"https://czihan-create.github.io/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","length":4}],"categories":[],"prev":{"title":"文章样式合集","date":"2025-08-23T12:42:11.000Z","slug":"文章样式合集","published":true,"updated":"2025-08-23T12:44:47.104Z","_id":"cmeoactk000066zyqh1nu21nd","layout":"post","photos":[],"excerpt":"","path":"2025/08/23/文章样式合集/","permalink":"https://czihan-create.github.io/2025/08/23/%E6%96%87%E7%AB%A0%E6%A0%B7%E5%BC%8F%E5%90%88%E9%9B%86/","__post":true},"next":{"title":"链接","date":"2025-08-09T08:18:18.000Z","summary":"记录一些实用的网站","slug":"链接","published":true,"updated":"2025-08-23T13:18:43.006Z","_id":"cmeoactk5000a6zyq3aax0g5w","layout":"post","photos":[],"excerpt":"","path":"2025/08/09/链接/","permalink":"https://czihan-create.github.io/2025/08/09/%E9%93%BE%E6%8E%A5/","__post":true},"__post":true}